%{



#include <stdio.h>
#include <stdarg.h>
#include "bash.h"
#include <string.h>
#include <stdbool.h>

void validate_redirection(struct command *cmd); //declaring function for rules

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// data structure to hold a linked list of arguments for a command
struct args {
    char *arg;
    struct args *next;
};

// data structure to hold a linked list of redirections for a command
struct redirs {
    int redir_token;
    char *filename;
    struct redirs *next;
};

/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0; //counter for syntax error
bool error_reported = false; //for multiple errors

%}

%union { /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
    struct args *pargs;
    struct redirs *predir;
    int number;
}

%token EOLN PIPE 
%token INFILE					// standard input redirection
%token OUTFILE OUTFILE_APPEND	// standard output redirection
%token ERRFILE ERRFILE_APPEND	// standard error redirection
%token <string> WORD

%type <pcmd> line cmd	// main datatype from bash.h
%type <pargs> optargs arg
%type <predir> optredirs redir

%%      /* beginning of the parsing rules */
input   : lines
        | 
        ;

lines   : oneline
        | oneline lines
        ;

oneline : line eoln
                { doline($1); }
        | eoln    /* blank line, do nothing */
        | error eoln
        ; 

eoln    : EOLN
                { ++lines; }
        ;

line    : cmd
        | cmd PIPE line
        {
            $$ = $1;
            $$->next = $3;  //link to the next command
            $$->outfile = "PIPE1"; //temp
            $3->infile = "PIPE1";   //link it to the next comman
        }
        | error { yyerrok; } //for parsing errors
        ;

cmd     : WORD optargs optredirs
        {
            if (!error_reported) {
                $$ = MallocZ(sizeof(struct command));
                $$->command = $1;
                $$->argc = 0;
                $$->argv[$$->argc++] = $1;

                // Handle PS1 setting
                if (strncmp($1, "PS1=", 4) == 0) {
                    $$->argv[$$->argc++] = strdup($1 + 4);
                } else {
                    // Handle other arguments
                    struct args *arglist = $2;
                    while (arglist) {
                        $$->argv[$$->argc++] = arglist->arg;
                        arglist = arglist->next;
                    }
                }
                $$->argv[$$->argc] = NULL;

                // Handle redirections
                struct redirs *redirlist = $3;
                bool has_infile = false;
                bool has_outfile = false;
                bool has_errfile = false;
                while (redirlist && !error_reported) {
                    switch (redirlist->redir_token) {
                        case INFILE:
                            if (has_infile) {
                                yyerror("illegal redirection");
                            } else {
                                $$->infile = redirlist->filename;
                                has_infile = true;
                            }
                            break;
                        case OUTFILE:
                        case OUTFILE_APPEND:
                            if (has_outfile) {
                                yyerror("illegal redirection");
                            } else {
                                $$->outfile = redirlist->filename;
                                $$->output_append = (redirlist->redir_token == OUTFILE_APPEND);
                                has_outfile = true;
                            }
                            break;
                        case ERRFILE:
                        case ERRFILE_APPEND:
                            if (has_errfile) {
                                yyerror("illegal redirection");
                            } else {
                                $$->errfile = redirlist->filename;
                                $$->error_append = (redirlist->redir_token == ERRFILE_APPEND);
                                has_errfile = true;
                            }
                            break;
                    }
                    redirlist = redirlist->next;
                }
                if (!error_reported) {
                    validate_redirection($$);
                }
            } else {
                $$ = NULL;
            }
        }
        | error
        {
            yyerror("Invalid command syntax");
            $$ = NULL;
        }
        ;
// optional argument list
optargs : arg optargs
        { 
            $$ = MallocZ(sizeof(struct args));
            $$->arg = strdup($1->arg);
            $$->next = $2; 
        }
        |	
        { $$ = NULL; }
        ;
// single argument rule
arg     : WORD
        {
            $$ = MallocZ(sizeof(struct args));
            $$->arg = strdup($1);  // Correctly use $1 which should be a char*
            $$->next = NULL; 
        }
        ;
//optional redirection list
optredirs : redir optredirs
        {
            $$ = MallocZ(sizeof(struct redirs));
            $$->redir_token = $1->redir_token; //to store type
            $$->filename = $1->filename; //to store filename
            $$->next = $2;
        }
        | 
        { $$ = NULL; } // no more redirection 
        ;
//single redirection
redir    : INFILE WORD
        {
            $$ = MallocZ(sizeof(struct redirs));
            $$->redir_token = INFILE;
            $$->filename = strdup($2);
        }
        | OUTFILE WORD
        {
            $$ = MallocZ(sizeof(struct redirs));
            $$->redir_token = OUTFILE;
            $$->filename = strdup($2);
        }
        | OUTFILE_APPEND WORD
        {
            $$ = MallocZ(sizeof(struct redirs));
            $$->redir_token = OUTFILE_APPEND;
            $$->filename = strdup($2);
        }
        | ERRFILE WORD
        {
            $$ = MallocZ(sizeof(struct redirs));
            $$->redir_token = ERRFILE;
            $$->filename = strdup($2);
        }
        | ERRFILE_APPEND WORD
        {
            $$ = MallocZ(sizeof(struct redirs));
            $$->redir_token = ERRFILE_APPEND;
            $$->filename = strdup($2);
        }
        ;

%%

//formatting redirections
void validate_redirection(struct command *cmd) {
    if (!error_reported) {
        if (cmd->infile && strcmp(cmd->infile, "") == 0) {
            yyerror("illegal redirection");
        } else if (cmd->outfile && strcmp(cmd->outfile, "") == 0) {
            yyerror("illegal redirection");
        } else if (cmd->errfile && strcmp(cmd->errfile, "") == 0) {
            yyerror("illegal redirection");
        } else if (cmd->infile && cmd->outfile && strcmp(cmd->infile, cmd->outfile) == 0) {
            yyerror("illegal redirection");
        }
    }
}


void
yyerror(const char *error_string, ...)
{
    va_list ap;
    // int line_nmb(void);
    // FILE *f = stdout;
    va_start(ap, error_string);
    ++synerrors;

    if (!error_reported) {
        fprintf(stdout, "Error on line %d: ", lines);
        vfprintf(stdout, error_string, ap);
        fprintf(stdout, "\n");
        error_reported = true;
    }
    va_end(ap);
}

// You should use this routine instead of malloc() to avoid some memory problems
#include <stdlib.h>

void *
MallocZ (int nbytes)
{
    char *ptr = malloc(nbytes);  // use the real routine
    if (ptr == NULL) {
        perror("MallocZ failed, fatal\n");
        exit(66);
    }

    // initialize the space to all zeroes
    memset(ptr, '\00', nbytes);
    return (ptr);
}